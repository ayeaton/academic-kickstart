---
title: K-Means
author: Anna Yeaton
date: '`r format(Sys.time(), "%d %B, %Y")`'
slug: k-means
categories: []
tags: ["Clustering"]
subtitle: ''
summary: 'Here we do K-means by hand!'
authors: ["Anna Yeaton"]
lastmod: '2020-01-05T18:42:22-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(tidyverse)
library(gganimate)
```

1. Choose the K number of clusters.
2. Split the data randomly into K groups.  
3. Iterate the following until the cluster assignments stop changing or until the predetermined number of iterations:
    * For each of the K clusters, compute the cluster centroid. The kth cluster centroid is the vector of the p feature means for the observations in the kth cluster. 
    * Assign each observation to the cluster whose centroid is the closest in squared euclidean distance. 


We will work with the Iris data. 

<button class="btn btn-primary" data-toggle="collapse" data-target="#BlockName"> Show/Hide </button>  
<div id="BlockName" class="collapse"> 

```{r}
data(iris)
# select the numeric data
iris_data <- iris %>% 
  select(c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width))
```

</div>


I did a Principal Components Analysis (PCA) using the iris_data, plotted the first two principal components, and colored the points by the iris species. This plot gives us a hint at the structure of the data. 
```{r echo=FALSE}
pca <- prcomp(iris_data)
set.seed(12)
pcs <- as.data.frame(pca$x)
(current_clust <- ggplot(pcs, aes(PC1, PC2, color = iris$Species)) + 
  geom_point() + 
    theme_bw()  +
    scale_color_manual(name = "Species",
                         values = sample(ghibli::ghibli_palettes$PonyoMedium, 3, replace = FALSE)))
```


## Step 1. Choose K number of clusters: 
I chose K equal to two for simplicity. This means that we are clustering the data into two groups. 
```{r}
K <- 2
```


## Step 2. Split the data randomly into K groups:
Now I split the data randomly into two groups (because I chose K to equal two).
```{r}
set.seed(10)
# Randomly assign a number, from 1 to K, to each of the observations. 

# Here I sampled from One or Two (because K equals two), for each data point in iris.
rand_idx <- sample(c("One", "Two"), nrow(iris_data), replace=TRUE, prob=c(0.5, 0.5))
# I add a column to the iris_data called cluster_id with the randomly assigned groups. 
iris_data$cluster_id <- rand_idx
```

On the PCA plot, we see that the two groups are randomly assigned. 
```{r echo=FALSE}
(current_clust <- ggplot(pcs, aes(PC1, PC2, color = iris_data$cluster_id )) + 
  geom_point() + 
    theme_bw()  +
    scale_color_manual(name = "Group",
                       values = c(One = "#0E84B4",
                                  Two = "#9E8356")))
```

## Step 3. Iterate the following until the cluster assigments stop changing

1. For each K cluster, compute the cluster centroid. 

2. Assign each observation to the cluster whose centroid is the closest in squared euclidean distance. 

Step 3.1 Compute the cluster centroid for each cluster by taking the mean of every point in each cluster. 
```{r}
(cluster_centroids <- iris_data %>% 
 group_by(cluster_id) %>% 
  summarise_at(vars(c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)), 
               ~mean(., na.rm=TRUE)) %>% 
   column_to_rownames("cluster_id"))
```

```{r echo=FALSE}
# project the cluster centroids on pca
centroid_points <- as.data.frame(scale(as.matrix(cluster_centroids), pca$center, pca$scale) %*% as.matrix(pca$rotation[, c("PC1", "PC2")]))

(current_clust <- ggplot(as.data.frame(pca$x), aes(PC1, PC2, colour = iris_data$cluster_id)) + 
  geom_point() + 
  theme_bw()  +
  geom_point(data = centroid_points , aes(PC1, PC2, colour = "Centroids")) +
  scale_color_manual(name = "Group",
                       values = c(One = "#0E84B4",
                                  Two = "#9E8356",
                                  Centroids = "#B50A2A")))
```


Step 3.2 Assign each observation to the cluster whose centroid is the closest in squared euclidean space.
```{r}
# our squared euclidean distance function 
sq_euclidean_dist <- function(x1, x2) {
  sum((x1 - x2) ^ 2)
}

# apply over the iris_data excluding the cluster_id
# calculate the squared euclidean distance between the row and the cluster 
# centroid of cluster "One"
dist_k1 <- apply(iris_data %>% select(-cluster_id), 
                 1, # rowwise
                 function(x){ 
                   sq_euclidean_dist(x, 
                                     as.numeric(cluster_centroids["One",]))
                   })

dist_k2 <- apply(iris_data %>% select(-cluster_id), 
                 1, # rowwise
                 function(x){ 
                   sq_euclidean_dist(x, 
                                     as.numeric(cluster_centroids["Two",]))
                   })
```


```{r}
distances <- data.frame(Cluster_one = dist_k1,
                        Cluster_two = dist_k2)
```

This distances data frame holds the distances of each data point in iris_data to the two cluster 
centroids. Distances has `r nrow(distances)` rows and `r ncol(distances)` columns. 

```{r}
head(distances)
```


So now we have to assign each point to the closest centroid. 
```{r}
# assign each observation to the closest cluster by
# iterating over the rows of the dataframe distances and finding which column 
# is the minimum value in that row. 
idx <- apply(distances, 1, function(x){ which.min(x)})
idx <- ifelse(idx == 1, "One", "Two")

iris_data$cluster_id <- idx
```


```{r echo=FALSE}
(current_clust <- ggplot(pcs, aes(PC1, PC2, color = iris_data$cluster_id )) + 
  geom_point() + 
    theme_bw()  +
    scale_color_manual(name = "Group",
                       values = c(One = "#0E84B4",
                                  Two = "#9E8356")))
```


Now we iterate over Step 3. We will only iterate for 3 times. 

```{r}

# Here I sampled from One or Two (because K equals two), for each data point in iris.
rand_idx <- sample(c("One", "Two"), nrow(iris_data), replace=TRUE, prob=c(0.5, 0.5))
# I add a column to the iris_data called cluster_id with the randomly assigned groups. 
iris_data$cluster_id <- rand_idx

save_pcs <- pcs[,c("PC1", "PC2")]
save_pcs$cluster <- rand_idx
save_pcs$id <- 1

cluster_centroids <- iris_data %>% 
     group_by(cluster_id) %>% 
     summarise_at(vars(c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)), 
               ~mean(., na.rm=TRUE)) %>% 
     column_to_rownames("cluster_id")
  
  centroid_points <- as.data.frame(scale(as.matrix(cluster_centroids),
                                         pca$center, pca$scale) %*% as.matrix(pca$rotation[, c("PC1", "PC2")]))
  centroid_points$cluster <- "Centroid"
  centroid_points$id <- 1
  save_pcs <- rbind(save_pcs, centroid_points)

for( i in 2:5){
  
  dist_k1 <- apply(iris_data %>% select(-cluster_id), 
                   1, # rowwise
                   function(x){ 
                     sq_euclidean_dist(x, 
                                       as.numeric(cluster_centroids["One",]))
                     })
  
  dist_k2 <- apply(iris_data %>% select(-cluster_id), 
                   1, # rowwise
                   function(x){ 
                     sq_euclidean_dist(x, 
                                       as.numeric(cluster_centroids["Two",]))
                     })
  
  distances <- data.frame(Cluster_one = dist_k1,
                          Cluster_two = dist_k2)
  
  idx <- apply(distances, 1, function(x){ which.min(x)})
  idx <- ifelse(idx == 1, "One", "Two")
  
  iris_data$cluster_id <- idx
  
  test <- pcs[,c("PC1", "PC2")]
  test$cluster <- idx
  test$id <- i
  
  save_pcs <- rbind(save_pcs, test)
  
  (cluster_centroids <- iris_data %>% 
     group_by(cluster_id) %>% 
     summarise_at(vars(c(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width)), 
               ~mean(., na.rm=TRUE)) %>% 
     column_to_rownames("cluster_id"))
  
  centroid_points <- as.data.frame(scale(as.matrix(cluster_centroids),
                                         pca$center, pca$scale) %*% as.matrix(pca$rotation[, c("PC1", "PC2")]))
  centroid_points$cluster <- "Centroid"
  centroid_points$id <- i
  save_pcs <- rbind(save_pcs, centroid_points)

}
```


```{r chunk-label, eval=FALSE, include=FALSE}
save_pcs$group <- seq_len(nrow(save_pcs))
(current_clust <- ggplot(save_pcs, aes(PC1, PC2, group = group, color = cluster)) +
  geom_point() +
  theme_bw()  +
  scale_color_manual(name = "Group",
                       values = c(One = "#0E84B4",
                                  Two = "#9E8356",
                                  Centroid = "red")) +
  transition_states(id, transition_length = 1, state_length = 1))

anim_save(animation = current_clust,
              file = "/Users/anna/Documents/academic-kickstart/static/post/2020-01-05-k-means_files/figure-html/kmeans.gif")

```

 

```{r echo=FALSE}
knitr::include_graphics("/post/2020-01-05-k-means_files/figure-html/kmeans.gif")
```


